       
#(#! 
(lisp::in-package "CONDITIONS" :use (lisp::quote ("LISP" "PCL")))
#(lisp::condition lisp::lambda (lisp::condition lisp::stream) (lisp::declare (lisp::ignore lisp::condition)) lisp::write-string lisp::stream "Ignore this DEFINE-CONDITION option." "Invalid DEFINE-CONDITION option: ~S" lisp::progn (lisp::eval-when (lisp::compile) (lisp::setq pcl::*defclass-times* (lisp::quote (lisp::compile lisp::load lisp::eval)))) pcl::defclass lisp::eval-when (lisp::compile lisp::load lisp::eval) lisp::pushnew lisp::quote :initarg :type conditions::*condition-class-list* lisp::setf lisp::get #0=(lisp::quote system::s-data) pcl::defmethod pcl::print-object conditions::x lisp::if lisp::*print-escape* (pcl::call-next-method) (conditions::x lisp::stream) lisp::standard-class "#<~S.~D>" "The condition ~A occurred." conditions::*condition-class* lisp::simple-type-error :datum :expected-type (lisp::satisfies conditions::condition-class-p) :format-string "Not a condition type: ~S" :format-arguments :report :documentation conditions::cerror pcl::load-defclass lisp::typep pcl::class-of pcl::class-name conditions::unique-id pcl::find-class pcl::class-precedence-list conditions::condition-class-p conditions::error pcl::make-instance (system::%init . #((lisp::if (lisp::fboundp (lisp::quote conditions::remove-clcs-symbols)) (lisp::progn (conditions::remove-clcs-symbols))) (system::*make-special (lisp::quote conditions::*condition-class-list*)) (lisp::or (lisp::boundp (lisp::quote conditions::*condition-class-list*)) (lisp::setq conditions::*condition-class-list* lisp::nil)) (system::mm (lisp::quote conditions::define-condition) 0) (system::mf (lisp::quote #1=#:|Defclass CONDITION2258|) 1) (#1#) (lisp::let* ((#2=#:g2278 (lisp::quote (lisp::condition lisp::nil)))) (lisp::setq conditions::*condition-class-list* (lisp::adjoin #2# conditions::*condition-class-list*))) (system::sputprop (lisp::quote lisp::condition) #0# lisp::nil) (lisp::if (lisp::fboundp (lisp::quote pcl::proclaim-incompatible-superclasses)) (lisp::progn (lisp::mapc (lisp::function pcl::proclaim-incompatible-superclasses) (lisp::quote ((lisp::condition pcl::metaobject)))))) (system::mf (lisp::quote conditions::conditionp) 2) (pcl::proclaim-defgeneric (lisp::quote pcl::print-object) (lisp::quote ((conditions::x lisp::condition) lisp::stream))) (system::mf (lisp::quote conditions::|(PCL::FAST-METHOD PRINT-OBJECT (CONDITION T))|) 3) (pcl::load-defmethod (lisp::quote lisp::standard-method) (lisp::quote pcl::print-object) (lisp::quote lisp::nil) (lisp::quote (lisp::condition lisp::t)) (lisp::quote (conditions::x lisp::stream)) (lisp::list* :fast-function (lisp::function conditions::|(PCL::FAST-METHOD PRINT-OBJECT (CONDITION T))|) (lisp::quote (:plist (:arg-info (2))))) (lisp::quote lisp::nil)) (system::*make-special (lisp::quote conditions::*condition-class*)) (lisp::or (lisp::boundp (lisp::quote conditions::*condition-class*)) (lisp::setq conditions::*condition-class* (pcl::find-class (lisp::quote lisp::condition)))) (system::mf (lisp::quote conditions::condition-class-p) 4) (system::mf (lisp::quote conditions::make-condition) 5) (system::debug (lisp::quote conditions::conditionp) (lisp::quote (lisp::object))) (system::debug (lisp::quote conditions::|(PCL::FAST-METHOD PRINT-OBJECT (CONDITION T))|) (lisp::quote (pcl::.pv-cell. pcl::.next-method-call. conditions::x lisp::stream))) (system::debug (lisp::quote conditions::condition-class-p) (lisp::quote (lisp::type))) (system::debug (lisp::quote conditions::make-condition) (lisp::quote (lisp::type conditions::slot-initializations))))))
)
